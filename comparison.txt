================================================================================
Python extension methods for HPC (picocrypto) – comparison
================================================================================

APPROACHES
----------
1. Cython
2. Cython + C helpers
3. ctypes / cffi (bind to C libs)
4. Rust + PyO3
5. Numba
6. Raw CPython (C API)
7. Pybind11
8. Nanobind

================================================================================
COMPARISON TABLE
================================================================================

| Approach           | Lang    | Deps              | Boilerplate | Build      | Big-int / crypto fit      |
|--------------------|---------|-------------------|-------------|------------|---------------------------|
| Cython             | .pyx    | Cython, C compiler| Low         | .pyx → C   | Good; big-int still Py    |
| Cython + C         | .pyx + C| Cython, C         | Medium      | .pyx + .c  | Best control in C kernel  |
| ctypes / cffi      | Python  | C lib (e.g. secp) | Low (glue)  | C lib only | Best if C lib exists      |
| Rust + PyO3        | Rust    | PyO3, maturin     | Low         | cargo      | Good; use Rust crypto crates |
| Numba              | Python  | numba             | Minimal     | JIT        | Poor; array-oriented      |
| Raw CPython        | C       | Python headers    | High        | .c → .so   | Full control, verbose    |
| Pybind11           | C++     | pybind11 (header)| Low         | C++ → .so  | Good; C++ crypto libs     |
| Nanobind           | C++     | nanobind         | Low         | C++ → .so  | Same as pybind, leaner    |

================================================================================
CONCISE POINTS BY APPROACH
================================================================================

Cython
  + Python-like, gradual typing, already in pyproject.
  + Single codebase, .py → .pyx incremental.
  - Big-int stays PyLong unless custom C limbs.
  - Maintain .pyx + Cython build.

Cython + C helpers
  + Max speed: hand-written C for Keccak/field ops.
  + Cython does Python boundary only.
  - Two languages, more build surface.
  - Debugging C + Cython.

ctypes / cffi
  + Bind libsecp256k1, libsodium, C Keccak; minimal Python glue.
  + Mature C libs, often constant-time.
  - Dependency on C lib (ship or system).
  - Packaging / wheels for C lib.

Rust + PyO3
  + One extension, modern crates (sha3, k256, ed25519-dalek).
  + No manual refcount, clean bindings.
  - Second language and toolchain (cargo, maturin).
  - Build and contributor Rust knowledge.

Numba
  + No separate compile; JIT on first run.
  - Bad fit: big-int and bytes-heavy crypto, not array math.
  - Not recommended for this codebase.

Raw CPython (C API)
  + No extra deps; full control; C only.
  + Ideal when crypto is already in C.
  - Verbose: Py_INCREF/DECREF, PyArg_ParseTuple, error handling.
  - Multi-version Python (#if PY_MAJOR) if needed.

Pybind11
  + C++ + clean bindings; little boilerplate.
  + Good for C++ crypto or wrapping C libs from C++.
  - C++ compiler and stdlib; template compile time.
  - Second “world” if rest is C/Cython.

Nanobind
  + Like pybind11 but smaller binary, faster compile, modern-only.
  + Preferred over pybind for new C++ extensions.
  - Still C++; smaller ecosystem than pybind11.

================================================================================
CONCLUSION
================================================================================

  • Best fit for picocrypto (current plan): CYTHON or CYTHON + C.
    Keeps one codebase, aligns with existing Cython in build; pure-Python
    fallback is straightforward.

  • If you implement crypto in C (e.g. Keccak/curves in .c): RAW CPYTHON
    is appropriate; minimal deps, full control, at the cost of C API
    boilerplate.

  • If you implement or wrap in C++: NANOBIND over Pybind11 (smaller,
    faster, modern). Use when you want C++ performance and a clean
    binding layer.

  • If you want maximum curve/hash performance and accept a C library
    dependency: CTYPES/CFFI to libsecp256k1 (and optionally libsodium)
    is the fastest path without maintaining crypto code yourself.

  • RUST + PyO3: good if you standardize on Rust and crypto crates;
    adds a second language and toolchain.

  • NUMBA: skip for this project; wrong fit for big-int/bytes crypto.

  Summary: Cython-first for consistency and low friction; raw CPython if
  you go C-only; nanobind if you go C++; ctypes/cffi for “use existing
  C lib” with minimal glue.

================================================================================
